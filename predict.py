'''
Created on May 7, 2016

@author: lxh5147
'''
from text_file_util import  TextFileUtil
from label_feature_map import LabelFeatureMap
from utilities import run
from convert_to_liblinear import Corpus
import argparse
from feature_extractor import feature_extractors

# update it to your local install
PREDICT_CMD = "/home/lxh5147/liblinear-2.1/predict"

class Prediction(object):
    '''
    Classification result
    '''
    def __init__(self, label_id, confidence):
        self._label_id = label_id
        self._confidence = confidence

    @property
    def label_id(self):
        return self._label_id

    @property
    def confidence(self):
        return self._confidence

class PredictionParser(object):
    def __init__(self, lable_to_id_map):
        self._id_to_label_map = PredictionParser._get_id_to_label_map(lable_to_id_map)
    
    @staticmethod
    def _get_id_to_label_map(lable_to_id_map):
        id_to_label_map = {}
        for label, label_id in lable_to_id_map.items():
            id_to_label_map[label_id] = label
        return id_to_label_map
        
    def parse_predictions(self, prediction_file_path, output_file_path):
        '''
        labels 1 -1
        -1 0.482154 0.517846
        '''
        output_file = TextFileUtil.open_file_write(output_file_path)
        # one blank line
        f = TextFileUtil.open_file_read(prediction_file_path)
        labels = f.readline().rstrip('\n').split(' ')[1:]
        # assert 
        for line in f:
            line = line.rstrip('\n')
            confidence_scores = line.split(' ')[1:]
            predictions = [Prediction(int(label_id), float(confidence)) for label_id, confidence in zip(labels, confidence_scores)]
            predictions.sort(cmp = lambda x, y:cmp(x.confidence, y.confidence), reverse = True)
            encoded_predictions = [self._id_to_label_map[prediction.label_id] + ":" + str(prediction.confidence) for prediction in predictions]
            TextFileUtil.write_file(output_file, ' '.join(encoded_predictions))
        f.close()
        output_file.close()

def predict(model_file_path, lable_feature_map_file_path, feature_extractors, input_file_path, prediction_file_path, output_file_path):
    # build corpus for prediction
    liblinear_file_path = input_file_path + ".liblinear"
    corpus = Corpus(input_file_path, lable_feature_map_file_path, feature_extractors)
    corpus.build(liblinear_file_path, is_for_training = False)
    # predict -q -b 1 convert_to_liblinear.test.liblinear model.liblinear predict.predictions.liblinear
    run(PREDICT_CMD + " -q -b 1 %s %s %s" % (liblinear_file_path, model_file_path, prediction_file_path))
    lable_to_id_map = LabelFeatureMap.load_label_map(lable_feature_map_file_path)
    prediction_parser = PredictionParser(lable_to_id_map)
    prediction_parser.parse_predictions(prediction_file_path, output_file_path)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description = 'Predict categories for all files under the prediction file root')
    parser.add_argument('predict_file_root', metavar = 'PREDICT_FILE_ROOT', help = 'root directory of all files, for which to run the prediction')
    parser.add_argument('--model', help = 'model file path')
    parser.add_argument('--map', help = 'category and feature map file path')
    parser.add_argument('--predict_input_file', nargs = '?', help = 'generated prediction input file')
    parser.add_argument('--prediction_file_path', help = 'prediction file generated by liblinear')
    parser.add_argument('--output_file_path', help = 'prediction file with human readable category names')

    args = parser.parse_args()
    predict_input_file = args.predict_input_file
    if predict_input_file is None:
        predict_input_file = "predict.input"
    Corpus.build_corpus_input_file(args.predict_file_root, predict_input_file)
    predict(args.model, args.map, feature_extractors, predict_input_file, args.prediction_file_path, args.output_file_path)
